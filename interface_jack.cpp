#include "interface_jack.h"

/* Auto-Generated by ChatGPT */

InterfaceJack::InterfaceJack(InterfaceAudio *parent)
    : InterfaceAudio(parent), client(nullptr)
{
    const char* client_name = "vkeybd-qt-jack";
    client = jack_client_open(client_name, JackNullOption, nullptr);
    if (!client) {
        qWarning() << "Failed to open JACK client";
        return;
    }
    
    jack_set_process_callback(client, jackCallback, this);
    
    if (jack_activate(client)) {
        qWarning() << "Cannot activate JACK client";
    }
}

InterfaceJack::~InterfaceJack()
{
    if (client) {
        jack_deactivate(client);
        jack_client_close(client);
    }
}

void InterfaceJack::createNewPort(QString label)
{
    if (!client) return;
    
    jack_port_t* port = jack_port_register(client,
                                           label.toUtf8(),
                                           JACK_DEFAULT_MIDI_TYPE,
                                           JackPortIsOutput,
                                           0);
    if (port)
        outputPorts.push_back(port);
}

void InterfaceJack::pushEvent(const MidiEvent &event)
{
    std::lock_guard<std::mutex> lock(bufferMutex);
    ringBuffer.push_back(event);
}

// JACK callback: called in real-time audio thread
int InterfaceJack::jackCallback(jack_nframes_t nframes, void *arg)
{
    InterfaceJack *self = static_cast<InterfaceJack*>(arg);
    self->processRingBuffer(nframes);
    return 0;
}

void InterfaceJack::processRingBuffer(jack_nframes_t nframes)
{
    std::lock_guard<std::mutex> lock(bufferMutex);
    
    for (auto &port : outputPorts) {
        void *buf = jack_port_get_buffer(port, nframes);
        jack_midi_clear_buffer(buf);
    }
    
    for (const MidiEvent &ev : ringBuffer) {
        if (ev.port < 0 || ev.port >= (int)outputPorts.size()) continue;
        
        void *buf = jack_port_get_buffer(outputPorts[ev.port], nframes);
        
        unsigned char midi[3];
        switch (ev.type) {
        case 0: // note on
            midi[0] = 0x90 | (ev.channel & 0x0F);
            midi[1] = ev.data1 & 0x7F;
            midi[2] = ev.data2 & 0x7F;
            jack_midi_event_write(buf, 0, midi, 3);
            break;
        case 1: // note off
            midi[0] = 0x80 | (ev.channel & 0x0F);
            midi[1] = ev.data1 & 0x7F;
            midi[2] = ev.data2 & 0x7F;
            jack_midi_event_write(buf, 0, midi, 3);
            break;
        case 2: // CC
            midi[0] = 0xB0 | (ev.channel & 0x0F);
            midi[1] = ev.data1 & 0x7F;
            midi[2] = ev.data2 & 0x7F;
            jack_midi_event_write(buf, 0, midi, 3);
            break;
        case 3: // Program Change
            midi[0] = 0xC0 | (ev.channel & 0x0F);
            midi[1] = ev.data1 & 0x7F;
            jack_midi_event_write(buf, 0, midi, 2);
            break;
        }
    }
    
    ringBuffer.clear();
}

// Event handlers
void InterfaceJack::keyPressEvent(int port, int channel, int midicode, int velocity)
{
    pushEvent({port, channel, 0, midicode, velocity});
}

void InterfaceJack::keyReleaseEvent(int port, int channel, int midicode, int velocity)
{
    pushEvent({port, channel, 1, midicode, velocity});
}

void InterfaceJack::keyPanicEvent(int port, int channel)
{
    for (int i = 0; i < 128; ++i)
        pushEvent({port, channel, 1, i, 127});
}

void InterfaceJack::keyStopAllEvent(int port, int channel)
{
    for (int i = 0; i < 128; ++i)
        pushEvent({port, channel, 2, 120, 127}); // All Sounds Off CC
}

void InterfaceJack::keyPitchbendEvent(int port, int channel, int pitch)
{
    int bend = pitch - 8192;
    pushEvent({port, channel, 2, 0xE0, bend & 0x7F}); // simplistic
}

void InterfaceJack::keySustainEvent(int port, int channel, bool pressed)
{
    pushEvent({port, channel, 2, 64, pressed ? 127 : 0});
}

void InterfaceJack::keySostenutoEvent(int port, int channel, bool pressed)
{
    pushEvent({port, channel, 2, 66, pressed ? 127 : 0});
}

void InterfaceJack::keySoftEvent(int port, int channel, bool pressed)
{
    pushEvent({port, channel, 2, 67, pressed ? 127 : 0});
}

void InterfaceJack::setProgramChangeEvent(int port, int channel, int program, int bank)
{
    if (bank < 0) bank = 0;
    
    // Bank MSB (CC0)
    int bankMSB = (bank >> 7) & 0x7F; // obere 7 Bits
    pushEvent({port, channel, 2, 0, bankMSB});
    
    // Bank LSB (CC32)
    int bankLSB = bank & 0x7F; // untere 7 Bits
    pushEvent({port, channel, 2, 32, bankLSB});
    
    // Program Change
    pushEvent({port, channel, 3, program & 0x7F, 0}); // data2 wird ignoriert
}

void InterfaceJack::setVolumeChangeEvent(int port, int channel, int volume)
{
    pushEvent({port, channel, 2, 7, volume});
}

void InterfaceJack::setPanChangeEvent(int port, int channel, int value)
{
    pushEvent({port, channel, 2, 10, value});
}

void InterfaceJack::setPortamentoChanged(int port, int channel, int value)
{
    pushEvent({port, channel, 2, 5, value});
}

void InterfaceJack::setAttackChanged(int port, int channel, int value)
{
    pushEvent({port, channel, 2, 73, value});
}

void InterfaceJack::setReleaseChanged(int port, int channel, int value)
{
    pushEvent({port, channel, 2, 72, value});
}

void InterfaceJack::setTremoloChanged(int port, int channel, int value)
{
    pushEvent({port, channel, 2, 1, value});
}
